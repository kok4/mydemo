// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: wilds.proto

/*
	Package usercmd is a generated protocol buffer package.

	It is generated from these files:
		wilds.proto

	It has these top-level messages:
		MsgLogin
		MsgLoginResult
		MsgTop
		MsgSceneTCP
		MsgSceneUDP
		MsgPlayer
		MsgAddPlayer
		MsgRefreshPlayer
		MsgRemovePlayer
		MsgMove
		MsgRelife
		MsgS2CRelife
		MsgDeath
		MsgEndRoom
		ClientHeartBeat
		MsgActCloseSocket
		MsgCastSkill
		MsgRun
		MsgSceneChat
		MsgPlayerSnap
		MsgBall
		MsgPlayerBall
		BallMove
		BallEat
		HitMsg
*/
package usercmd

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type MsgTypeCmd int32

const (
	MsgTypeCmd_Login          MsgTypeCmd = 1001
	MsgTypeCmd_Top            MsgTypeCmd = 1002
	MsgTypeCmd_AddPlayer      MsgTypeCmd = 1003
	MsgTypeCmd_RemovePlayer   MsgTypeCmd = 1004
	MsgTypeCmd_Move           MsgTypeCmd = 1006
	MsgTypeCmd_Run            MsgTypeCmd = 1007
	MsgTypeCmd_ReLife         MsgTypeCmd = 1009
	MsgTypeCmd_Death          MsgTypeCmd = 1010
	MsgTypeCmd_EndRoom        MsgTypeCmd = 1011
	MsgTypeCmd_RefreshPlayer  MsgTypeCmd = 1013
	MsgTypeCmd_HeartBeat      MsgTypeCmd = 1016
	MsgTypeCmd_SceneChat      MsgTypeCmd = 1020
	MsgTypeCmd_ActCloseSocket MsgTypeCmd = 1021
	MsgTypeCmd_ErrorMsg       MsgTypeCmd = 1025
	MsgTypeCmd_SceneTCP       MsgTypeCmd = 1031
	MsgTypeCmd_SceneUDP       MsgTypeCmd = 1032
	MsgTypeCmd_CastSkill      MsgTypeCmd = 1050
)

var MsgTypeCmd_name = map[int32]string{
	1001: "Login",
	1002: "Top",
	1003: "AddPlayer",
	1004: "RemovePlayer",
	1006: "Move",
	1007: "Run",
	1009: "ReLife",
	1010: "Death",
	1011: "EndRoom",
	1013: "RefreshPlayer",
	1016: "HeartBeat",
	1020: "SceneChat",
	1021: "ActCloseSocket",
	1025: "ErrorMsg",
	1031: "SceneTCP",
	1032: "SceneUDP",
	1050: "CastSkill",
}
var MsgTypeCmd_value = map[string]int32{
	"Login":          1001,
	"Top":            1002,
	"AddPlayer":      1003,
	"RemovePlayer":   1004,
	"Move":           1006,
	"Run":            1007,
	"ReLife":         1009,
	"Death":          1010,
	"EndRoom":        1011,
	"RefreshPlayer":  1013,
	"HeartBeat":      1016,
	"SceneChat":      1020,
	"ActCloseSocket": 1021,
	"ErrorMsg":       1025,
	"SceneTCP":       1031,
	"SceneUDP":       1032,
	"CastSkill":      1050,
}

func (x MsgTypeCmd) Enum() *MsgTypeCmd {
	p := new(MsgTypeCmd)
	*p = x
	return p
}
func (x MsgTypeCmd) String() string {
	return proto.EnumName(MsgTypeCmd_name, int32(x))
}
func (x *MsgTypeCmd) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MsgTypeCmd_value, data, "MsgTypeCmd")
	if err != nil {
		return err
	}
	*x = MsgTypeCmd(value)
	return nil
}
func (MsgTypeCmd) EnumDescriptor() ([]byte, []int) { return fileDescriptorWilds, []int{0} }

type MapObjectConfigType int32

const (
	MapObjectConfigType_Empty MapObjectConfigType = 0
	MapObjectConfigType_Block MapObjectConfigType = 1
)

var MapObjectConfigType_name = map[int32]string{
	0: "Empty",
	1: "Block",
}
var MapObjectConfigType_value = map[string]int32{
	"Empty": 0,
	"Block": 1,
}

func (x MapObjectConfigType) Enum() *MapObjectConfigType {
	p := new(MapObjectConfigType)
	*p = x
	return p
}
func (x MapObjectConfigType) String() string {
	return proto.EnumName(MapObjectConfigType_name, int32(x))
}
func (x *MapObjectConfigType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MapObjectConfigType_value, data, "MapObjectConfigType")
	if err != nil {
		return err
	}
	*x = MapObjectConfigType(value)
	return nil
}
func (MapObjectConfigType) EnumDescriptor() ([]byte, []int) { return fileDescriptorWilds, []int{1} }

type BallType int32

const (
	BallType_Player      BallType = 1
	BallType_FoodBegin   BallType = 10
	BallType_FoodNormal  BallType = 11
	BallType_FoodHammer  BallType = 12
	BallType_FoodBomb    BallType = 13
	BallType_FoodEnd     BallType = 19
	BallType_FeedBegin   BallType = 20
	BallType_FeedNormal  BallType = 21
	BallType_FeedEnd     BallType = 29
	BallType_SkillBegin  BallType = 30
	BallType_SkillHammer BallType = 31
	BallType_SkillBomb   BallType = 32
	BallType_SkillEnd    BallType = 39
)

var BallType_name = map[int32]string{
	1:  "Player",
	10: "FoodBegin",
	11: "FoodNormal",
	12: "FoodHammer",
	13: "FoodBomb",
	19: "FoodEnd",
	20: "FeedBegin",
	21: "FeedNormal",
	29: "FeedEnd",
	30: "SkillBegin",
	31: "SkillHammer",
	32: "SkillBomb",
	39: "SkillEnd",
}
var BallType_value = map[string]int32{
	"Player":      1,
	"FoodBegin":   10,
	"FoodNormal":  11,
	"FoodHammer":  12,
	"FoodBomb":    13,
	"FoodEnd":     19,
	"FeedBegin":   20,
	"FeedNormal":  21,
	"FeedEnd":     29,
	"SkillBegin":  30,
	"SkillHammer": 31,
	"SkillBomb":   32,
	"SkillEnd":    39,
}

func (x BallType) Enum() *BallType {
	p := new(BallType)
	*p = x
	return p
}
func (x BallType) String() string {
	return proto.EnumName(BallType_name, int32(x))
}
func (x *BallType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(BallType_value, data, "BallType")
	if err != nil {
		return err
	}
	*x = BallType(value)
	return nil
}
func (BallType) EnumDescriptor() ([]byte, []int) { return fileDescriptorWilds, []int{2} }

// 请求登录
type MsgLogin struct {
	Name string `protobuf:"bytes,1,req,name=name" json:"name"`
}

func (m *MsgLogin) Reset()                    { *m = MsgLogin{} }
func (m *MsgLogin) String() string            { return proto.CompactTextString(m) }
func (*MsgLogin) ProtoMessage()               {}
func (*MsgLogin) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{0} }

func (m *MsgLogin) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// 返回登录
type MsgLoginResult struct {
	Ok          bool             `protobuf:"varint,1,req,name=ok" json:"ok"`
	Id          uint64           `protobuf:"varint,2,req,name=id" json:"id"`
	Name        string           `protobuf:"bytes,3,opt,name=name" json:"name"`
	Others      []*MsgPlayer     `protobuf:"bytes,4,rep,name=others" json:"others,omitempty"`
	Frame       uint32           `protobuf:"varint,5,req,name=frame" json:"frame"`
	BallId      uint32           `protobuf:"varint,8,req,name=ballId" json:"ballId"`
	Balls       []*MsgBall       `protobuf:"bytes,9,rep,name=balls" json:"balls,omitempty"`
	Playerballs []*MsgPlayerBall `protobuf:"bytes,10,rep,name=playerballs" json:"playerballs,omitempty"`
	LeftTime    uint32           `protobuf:"varint,14,opt,name=leftTime" json:"leftTime"`
}

func (m *MsgLoginResult) Reset()                    { *m = MsgLoginResult{} }
func (m *MsgLoginResult) String() string            { return proto.CompactTextString(m) }
func (*MsgLoginResult) ProtoMessage()               {}
func (*MsgLoginResult) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{1} }

func (m *MsgLoginResult) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *MsgLoginResult) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MsgLoginResult) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgLoginResult) GetOthers() []*MsgPlayer {
	if m != nil {
		return m.Others
	}
	return nil
}

func (m *MsgLoginResult) GetFrame() uint32 {
	if m != nil {
		return m.Frame
	}
	return 0
}

func (m *MsgLoginResult) GetBallId() uint32 {
	if m != nil {
		return m.BallId
	}
	return 0
}

func (m *MsgLoginResult) GetBalls() []*MsgBall {
	if m != nil {
		return m.Balls
	}
	return nil
}

func (m *MsgLoginResult) GetPlayerballs() []*MsgPlayerBall {
	if m != nil {
		return m.Playerballs
	}
	return nil
}

func (m *MsgLoginResult) GetLeftTime() uint32 {
	if m != nil {
		return m.LeftTime
	}
	return 0
}

// 返回排行榜Top
type MsgTop struct {
	Players []*MsgPlayer `protobuf:"bytes,1,rep,name=players" json:"players,omitempty"`
	EndTime uint32       `protobuf:"varint,3,opt,name=EndTime,json=endTime" json:"EndTime"`
	Rank    uint32       `protobuf:"varint,4,opt,name=Rank,json=rank" json:"Rank"`
	KillNum uint32       `protobuf:"varint,5,opt,name=KillNum,json=killNum" json:"KillNum"`
}

func (m *MsgTop) Reset()                    { *m = MsgTop{} }
func (m *MsgTop) String() string            { return proto.CompactTextString(m) }
func (*MsgTop) ProtoMessage()               {}
func (*MsgTop) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{2} }

func (m *MsgTop) GetPlayers() []*MsgPlayer {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *MsgTop) GetEndTime() uint32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *MsgTop) GetRank() uint32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *MsgTop) GetKillNum() uint32 {
	if m != nil {
		return m.KillNum
	}
	return 0
}

type MsgSceneTCP struct {
	Eats          []*BallEat       `protobuf:"bytes,1,rep,name=eats" json:"eats,omitempty"`
	Adds          []*MsgBall       `protobuf:"bytes,2,rep,name=adds" json:"adds,omitempty"`
	Removes       []uint32         `protobuf:"varint,3,rep,name=removes" json:"removes,omitempty"`
	Hits          []*HitMsg        `protobuf:"bytes,4,rep,name=hits" json:"hits,omitempty"`
	AddPlayers    []*MsgPlayerBall `protobuf:"bytes,5,rep,name=addPlayers" json:"addPlayers,omitempty"`
	RemovePlayers []uint32         `protobuf:"varint,6,rep,name=removePlayers" json:"removePlayers,omitempty"`
}

func (m *MsgSceneTCP) Reset()                    { *m = MsgSceneTCP{} }
func (m *MsgSceneTCP) String() string            { return proto.CompactTextString(m) }
func (*MsgSceneTCP) ProtoMessage()               {}
func (*MsgSceneTCP) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{3} }

func (m *MsgSceneTCP) GetEats() []*BallEat {
	if m != nil {
		return m.Eats
	}
	return nil
}

func (m *MsgSceneTCP) GetAdds() []*MsgBall {
	if m != nil {
		return m.Adds
	}
	return nil
}

func (m *MsgSceneTCP) GetRemoves() []uint32 {
	if m != nil {
		return m.Removes
	}
	return nil
}

func (m *MsgSceneTCP) GetHits() []*HitMsg {
	if m != nil {
		return m.Hits
	}
	return nil
}

func (m *MsgSceneTCP) GetAddPlayers() []*MsgPlayerBall {
	if m != nil {
		return m.AddPlayers
	}
	return nil
}

func (m *MsgSceneTCP) GetRemovePlayers() []uint32 {
	if m != nil {
		return m.RemovePlayers
	}
	return nil
}

type MsgSceneUDP struct {
	Moves []*BallMove `protobuf:"bytes,1,rep,name=moves" json:"moves,omitempty"`
	Frame uint32      `protobuf:"varint,2,req,name=frame" json:"frame"`
}

func (m *MsgSceneUDP) Reset()                    { *m = MsgSceneUDP{} }
func (m *MsgSceneUDP) String() string            { return proto.CompactTextString(m) }
func (*MsgSceneUDP) ProtoMessage()               {}
func (*MsgSceneUDP) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{4} }

func (m *MsgSceneUDP) GetMoves() []*BallMove {
	if m != nil {
		return m.Moves
	}
	return nil
}

func (m *MsgSceneUDP) GetFrame() uint32 {
	if m != nil {
		return m.Frame
	}
	return 0
}

// 玩家数据
type MsgPlayer struct {
	Id        uint64         `protobuf:"varint,1,req,name=id" json:"id"`
	Name      string         `protobuf:"bytes,2,req,name=name" json:"name"`
	IsLive    bool           `protobuf:"varint,4,opt,name=IsLive,json=isLive" json:"IsLive"`
	SnapInfo  *MsgPlayerSnap `protobuf:"bytes,5,opt,name=SnapInfo,json=snapInfo" json:"SnapInfo,omitempty"`
	BallId    uint32         `protobuf:"varint,6,req,name=ballId" json:"ballId"`
	Curexp    uint32         `protobuf:"varint,7,opt,name=curexp" json:"curexp"`
	Curmp     uint32         `protobuf:"varint,8,opt,name=curmp" json:"curmp"`
	Curhp     uint32         `protobuf:"varint,10,opt,name=curhp" json:"curhp"`
	BombNum   int32          `protobuf:"varint,12,opt,name=bombNum" json:"bombNum"`
	HammerNum int32          `protobuf:"varint,13,opt,name=hammerNum" json:"hammerNum"`
}

func (m *MsgPlayer) Reset()                    { *m = MsgPlayer{} }
func (m *MsgPlayer) String() string            { return proto.CompactTextString(m) }
func (*MsgPlayer) ProtoMessage()               {}
func (*MsgPlayer) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{5} }

func (m *MsgPlayer) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MsgPlayer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgPlayer) GetIsLive() bool {
	if m != nil {
		return m.IsLive
	}
	return false
}

func (m *MsgPlayer) GetSnapInfo() *MsgPlayerSnap {
	if m != nil {
		return m.SnapInfo
	}
	return nil
}

func (m *MsgPlayer) GetBallId() uint32 {
	if m != nil {
		return m.BallId
	}
	return 0
}

func (m *MsgPlayer) GetCurexp() uint32 {
	if m != nil {
		return m.Curexp
	}
	return 0
}

func (m *MsgPlayer) GetCurmp() uint32 {
	if m != nil {
		return m.Curmp
	}
	return 0
}

func (m *MsgPlayer) GetCurhp() uint32 {
	if m != nil {
		return m.Curhp
	}
	return 0
}

func (m *MsgPlayer) GetBombNum() int32 {
	if m != nil {
		return m.BombNum
	}
	return 0
}

func (m *MsgPlayer) GetHammerNum() int32 {
	if m != nil {
		return m.HammerNum
	}
	return 0
}

// 返回添加玩家 AddPlayer
type MsgAddPlayer struct {
	Player *MsgPlayer `protobuf:"bytes,1,req,name=player" json:"player,omitempty"`
}

func (m *MsgAddPlayer) Reset()                    { *m = MsgAddPlayer{} }
func (m *MsgAddPlayer) String() string            { return proto.CompactTextString(m) }
func (*MsgAddPlayer) ProtoMessage()               {}
func (*MsgAddPlayer) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{6} }

func (m *MsgAddPlayer) GetPlayer() *MsgPlayer {
	if m != nil {
		return m.Player
	}
	return nil
}

// 返回刷新玩家数据
type MsgRefreshPlayer struct {
	Player *MsgPlayer `protobuf:"bytes,1,req,name=player" json:"player,omitempty"`
}

func (m *MsgRefreshPlayer) Reset()                    { *m = MsgRefreshPlayer{} }
func (m *MsgRefreshPlayer) String() string            { return proto.CompactTextString(m) }
func (*MsgRefreshPlayer) ProtoMessage()               {}
func (*MsgRefreshPlayer) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{7} }

func (m *MsgRefreshPlayer) GetPlayer() *MsgPlayer {
	if m != nil {
		return m.Player
	}
	return nil
}

// 返回删除玩家 RemovePlayer
type MsgRemovePlayer struct {
	Id uint64 `protobuf:"varint,1,req,name=id" json:"id"`
}

func (m *MsgRemovePlayer) Reset()                    { *m = MsgRemovePlayer{} }
func (m *MsgRemovePlayer) String() string            { return proto.CompactTextString(m) }
func (*MsgRemovePlayer) ProtoMessage()               {}
func (*MsgRemovePlayer) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{8} }

func (m *MsgRemovePlayer) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// 请求移动 Move
type MsgMove struct {
	Angle int32  `protobuf:"varint,1,req,name=angle" json:"angle"`
	Power int32  `protobuf:"varint,2,req,name=power" json:"power"`
	Face  uint32 `protobuf:"varint,3,opt,name=face" json:"face"`
}

func (m *MsgMove) Reset()                    { *m = MsgMove{} }
func (m *MsgMove) String() string            { return proto.CompactTextString(m) }
func (*MsgMove) ProtoMessage()               {}
func (*MsgMove) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{9} }

func (m *MsgMove) GetAngle() int32 {
	if m != nil {
		return m.Angle
	}
	return 0
}

func (m *MsgMove) GetPower() int32 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *MsgMove) GetFace() uint32 {
	if m != nil {
		return m.Face
	}
	return 0
}

// 请求复活 ReLife
type MsgRelife struct {
}

func (m *MsgRelife) Reset()                    { *m = MsgRelife{} }
func (m *MsgRelife) String() string            { return proto.CompactTextString(m) }
func (*MsgRelife) ProtoMessage()               {}
func (*MsgRelife) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{10} }

// 返回复活 ReLife
type MsgS2CRelife struct {
	Name     string         `protobuf:"bytes,1,opt,name=name" json:"name"`
	Frame    uint32         `protobuf:"varint,2,opt,name=frame" json:"frame"`
	SnapInfo *MsgPlayerSnap `protobuf:"bytes,3,req,name=SnapInfo,json=snapInfo" json:"SnapInfo,omitempty"`
	Curhp    uint32         `protobuf:"varint,4,opt,name=curhp" json:"curhp"`
	Curmp    uint32         `protobuf:"varint,5,opt,name=curmp" json:"curmp"`
}

func (m *MsgS2CRelife) Reset()                    { *m = MsgS2CRelife{} }
func (m *MsgS2CRelife) String() string            { return proto.CompactTextString(m) }
func (*MsgS2CRelife) ProtoMessage()               {}
func (*MsgS2CRelife) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{11} }

func (m *MsgS2CRelife) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgS2CRelife) GetFrame() uint32 {
	if m != nil {
		return m.Frame
	}
	return 0
}

func (m *MsgS2CRelife) GetSnapInfo() *MsgPlayerSnap {
	if m != nil {
		return m.SnapInfo
	}
	return nil
}

func (m *MsgS2CRelife) GetCurhp() uint32 {
	if m != nil {
		return m.Curhp
	}
	return 0
}

func (m *MsgS2CRelife) GetCurmp() uint32 {
	if m != nil {
		return m.Curmp
	}
	return 0
}

// 返回死亡 Death
type MsgDeath struct {
	MaxScore uint32 `protobuf:"varint,1,req,name=maxScore" json:"maxScore"`
	KillId   uint64 `protobuf:"varint,2,req,name=killId" json:"killId"`
	KillName string `protobuf:"bytes,3,req,name=killName" json:"killName"`
	Id       uint64 `protobuf:"varint,4,req,name=Id,json=id" json:"Id"`
}

func (m *MsgDeath) Reset()                    { *m = MsgDeath{} }
func (m *MsgDeath) String() string            { return proto.CompactTextString(m) }
func (*MsgDeath) ProtoMessage()               {}
func (*MsgDeath) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{12} }

func (m *MsgDeath) GetMaxScore() uint32 {
	if m != nil {
		return m.MaxScore
	}
	return 0
}

func (m *MsgDeath) GetKillId() uint64 {
	if m != nil {
		return m.KillId
	}
	return 0
}

func (m *MsgDeath) GetKillName() string {
	if m != nil {
		return m.KillName
	}
	return ""
}

func (m *MsgDeath) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// 返回结束 EndRoom
type MsgEndRoom struct {
}

func (m *MsgEndRoom) Reset()                    { *m = MsgEndRoom{} }
func (m *MsgEndRoom) String() string            { return proto.CompactTextString(m) }
func (*MsgEndRoom) ProtoMessage()               {}
func (*MsgEndRoom) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{13} }

// 客户端心跳包
type ClientHeartBeat struct {
}

func (m *ClientHeartBeat) Reset()                    { *m = ClientHeartBeat{} }
func (m *ClientHeartBeat) String() string            { return proto.CompactTextString(m) }
func (*ClientHeartBeat) ProtoMessage()               {}
func (*ClientHeartBeat) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{14} }

type MsgActCloseSocket struct {
}

func (m *MsgActCloseSocket) Reset()                    { *m = MsgActCloseSocket{} }
func (m *MsgActCloseSocket) String() string            { return proto.CompactTextString(m) }
func (*MsgActCloseSocket) ProtoMessage()               {}
func (*MsgActCloseSocket) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{15} }

// 释放技能 CastSkill
type MsgCastSkill struct {
	Skillid uint32 `protobuf:"varint,1,opt,name=skillid" json:"skillid"`
}

func (m *MsgCastSkill) Reset()                    { *m = MsgCastSkill{} }
func (m *MsgCastSkill) String() string            { return proto.CompactTextString(m) }
func (*MsgCastSkill) ProtoMessage()               {}
func (*MsgCastSkill) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{16} }

func (m *MsgCastSkill) GetSkillid() uint32 {
	if m != nil {
		return m.Skillid
	}
	return 0
}

// 奔跑
type MsgRun struct {
}

func (m *MsgRun) Reset()                    { *m = MsgRun{} }
func (m *MsgRun) String() string            { return proto.CompactTextString(m) }
func (*MsgRun) ProtoMessage()               {}
func (*MsgRun) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{17} }

// 聊天命令命令
type MsgSceneChat struct {
	Msg string `protobuf:"bytes,1,req,name=Msg,json=msg" json:"Msg"`
	Id  uint64 `protobuf:"varint,2,req,name=Id,json=id" json:"Id"`
}

func (m *MsgSceneChat) Reset()                    { *m = MsgSceneChat{} }
func (m *MsgSceneChat) String() string            { return proto.CompactTextString(m) }
func (*MsgSceneChat) ProtoMessage()               {}
func (*MsgSceneChat) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{18} }

func (m *MsgSceneChat) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *MsgSceneChat) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// 位置同步
type MsgPlayerSnap struct {
	Snapx float32 `protobuf:"fixed32,1,req,name=Snapx,json=snapx" json:"Snapx"`
	Snapy float32 `protobuf:"fixed32,2,req,name=Snapy,json=snapy" json:"Snapy"`
	Angle float32 `protobuf:"fixed32,3,req,name=Angle,json=angle" json:"Angle"`
	Id    uint64  `protobuf:"varint,4,req,name=Id,json=id" json:"Id"`
}

func (m *MsgPlayerSnap) Reset()                    { *m = MsgPlayerSnap{} }
func (m *MsgPlayerSnap) String() string            { return proto.CompactTextString(m) }
func (*MsgPlayerSnap) ProtoMessage()               {}
func (*MsgPlayerSnap) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{19} }

func (m *MsgPlayerSnap) GetSnapx() float32 {
	if m != nil {
		return m.Snapx
	}
	return 0
}

func (m *MsgPlayerSnap) GetSnapy() float32 {
	if m != nil {
		return m.Snapy
	}
	return 0
}

func (m *MsgPlayerSnap) GetAngle() float32 {
	if m != nil {
		return m.Angle
	}
	return 0
}

func (m *MsgPlayerSnap) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type MsgBall struct {
	Id   uint32 `protobuf:"varint,1,req,name=id" json:"id"`
	Type int32  `protobuf:"varint,2,req,name=type" json:"type"`
	X    int32  `protobuf:"varint,3,req,name=x" json:"x"`
	Y    int32  `protobuf:"varint,4,req,name=y" json:"y"`
}

func (m *MsgBall) Reset()                    { *m = MsgBall{} }
func (m *MsgBall) String() string            { return proto.CompactTextString(m) }
func (*MsgBall) ProtoMessage()               {}
func (*MsgBall) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{20} }

func (m *MsgBall) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MsgBall) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *MsgBall) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *MsgBall) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

// 玩家球
type MsgPlayerBall struct {
	Id    uint32 `protobuf:"varint,1,req,name=id" json:"id"`
	Hp    uint32 `protobuf:"varint,3,opt,name=hp" json:"hp"`
	Mp    uint32 `protobuf:"varint,4,opt,name=mp" json:"mp"`
	X     int32  `protobuf:"varint,5,req,name=x" json:"x"`
	Y     int32  `protobuf:"varint,6,req,name=y" json:"y"`
	Angle int32  `protobuf:"varint,7,opt,name=angle" json:"angle"`
	Face  uint32 `protobuf:"varint,8,opt,name=face" json:"face"`
}

func (m *MsgPlayerBall) Reset()                    { *m = MsgPlayerBall{} }
func (m *MsgPlayerBall) String() string            { return proto.CompactTextString(m) }
func (*MsgPlayerBall) ProtoMessage()               {}
func (*MsgPlayerBall) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{21} }

func (m *MsgPlayerBall) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MsgPlayerBall) GetHp() uint32 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *MsgPlayerBall) GetMp() uint32 {
	if m != nil {
		return m.Mp
	}
	return 0
}

func (m *MsgPlayerBall) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *MsgPlayerBall) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *MsgPlayerBall) GetAngle() int32 {
	if m != nil {
		return m.Angle
	}
	return 0
}

func (m *MsgPlayerBall) GetFace() uint32 {
	if m != nil {
		return m.Face
	}
	return 0
}

// 移动数据
type BallMove struct {
	Id    uint32 `protobuf:"varint,1,req,name=id" json:"id"`
	X     int32  `protobuf:"varint,2,req,name=x" json:"x"`
	Y     int32  `protobuf:"varint,3,req,name=y" json:"y"`
	State uint32 `protobuf:"varint,4,opt,name=state" json:"state"`
	Angle int32  `protobuf:"varint,5,opt,name=angle" json:"angle"`
	Face  uint32 `protobuf:"varint,6,opt,name=face" json:"face"`
}

func (m *BallMove) Reset()                    { *m = BallMove{} }
func (m *BallMove) String() string            { return proto.CompactTextString(m) }
func (*BallMove) ProtoMessage()               {}
func (*BallMove) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{22} }

func (m *BallMove) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BallMove) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *BallMove) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *BallMove) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *BallMove) GetAngle() int32 {
	if m != nil {
		return m.Angle
	}
	return 0
}

func (m *BallMove) GetFace() uint32 {
	if m != nil {
		return m.Face
	}
	return 0
}

// 吃球
type BallEat struct {
	Source uint32 `protobuf:"varint,1,req,name=source" json:"source"`
	Target uint32 `protobuf:"varint,2,req,name=target" json:"target"`
}

func (m *BallEat) Reset()                    { *m = BallEat{} }
func (m *BallEat) String() string            { return proto.CompactTextString(m) }
func (*BallEat) ProtoMessage()               {}
func (*BallEat) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{23} }

func (m *BallEat) GetSource() uint32 {
	if m != nil {
		return m.Source
	}
	return 0
}

func (m *BallEat) GetTarget() uint32 {
	if m != nil {
		return m.Target
	}
	return 0
}

// 攻击
type HitMsg struct {
	Source uint32 `protobuf:"varint,1,req,name=source" json:"source"`
	Target uint32 `protobuf:"varint,2,req,name=target" json:"target"`
	AddHp  int32  `protobuf:"varint,3,opt,name=addHp" json:"addHp"`
	CurHp  uint32 `protobuf:"varint,4,opt,name=curHp" json:"curHp"`
}

func (m *HitMsg) Reset()                    { *m = HitMsg{} }
func (m *HitMsg) String() string            { return proto.CompactTextString(m) }
func (*HitMsg) ProtoMessage()               {}
func (*HitMsg) Descriptor() ([]byte, []int) { return fileDescriptorWilds, []int{24} }

func (m *HitMsg) GetSource() uint32 {
	if m != nil {
		return m.Source
	}
	return 0
}

func (m *HitMsg) GetTarget() uint32 {
	if m != nil {
		return m.Target
	}
	return 0
}

func (m *HitMsg) GetAddHp() int32 {
	if m != nil {
		return m.AddHp
	}
	return 0
}

func (m *HitMsg) GetCurHp() uint32 {
	if m != nil {
		return m.CurHp
	}
	return 0
}

func init() {
	proto.RegisterType((*MsgLogin)(nil), "usercmd.MsgLogin")
	proto.RegisterType((*MsgLoginResult)(nil), "usercmd.MsgLoginResult")
	proto.RegisterType((*MsgTop)(nil), "usercmd.MsgTop")
	proto.RegisterType((*MsgSceneTCP)(nil), "usercmd.MsgSceneTCP")
	proto.RegisterType((*MsgSceneUDP)(nil), "usercmd.MsgSceneUDP")
	proto.RegisterType((*MsgPlayer)(nil), "usercmd.MsgPlayer")
	proto.RegisterType((*MsgAddPlayer)(nil), "usercmd.MsgAddPlayer")
	proto.RegisterType((*MsgRefreshPlayer)(nil), "usercmd.MsgRefreshPlayer")
	proto.RegisterType((*MsgRemovePlayer)(nil), "usercmd.MsgRemovePlayer")
	proto.RegisterType((*MsgMove)(nil), "usercmd.MsgMove")
	proto.RegisterType((*MsgRelife)(nil), "usercmd.MsgRelife")
	proto.RegisterType((*MsgS2CRelife)(nil), "usercmd.MsgS2CRelife")
	proto.RegisterType((*MsgDeath)(nil), "usercmd.MsgDeath")
	proto.RegisterType((*MsgEndRoom)(nil), "usercmd.MsgEndRoom")
	proto.RegisterType((*ClientHeartBeat)(nil), "usercmd.ClientHeartBeat")
	proto.RegisterType((*MsgActCloseSocket)(nil), "usercmd.MsgActCloseSocket")
	proto.RegisterType((*MsgCastSkill)(nil), "usercmd.MsgCastSkill")
	proto.RegisterType((*MsgRun)(nil), "usercmd.MsgRun")
	proto.RegisterType((*MsgSceneChat)(nil), "usercmd.MsgSceneChat")
	proto.RegisterType((*MsgPlayerSnap)(nil), "usercmd.MsgPlayerSnap")
	proto.RegisterType((*MsgBall)(nil), "usercmd.MsgBall")
	proto.RegisterType((*MsgPlayerBall)(nil), "usercmd.MsgPlayerBall")
	proto.RegisterType((*BallMove)(nil), "usercmd.BallMove")
	proto.RegisterType((*BallEat)(nil), "usercmd.BallEat")
	proto.RegisterType((*HitMsg)(nil), "usercmd.HitMsg")
	proto.RegisterEnum("usercmd.MsgTypeCmd", MsgTypeCmd_name, MsgTypeCmd_value)
	proto.RegisterEnum("usercmd.MapObjectConfigType", MapObjectConfigType_name, MapObjectConfigType_value)
	proto.RegisterEnum("usercmd.BallType", BallType_name, BallType_value)
}
func (m *MsgLogin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLogin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintWilds(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}

func (m *MsgLoginResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLoginResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Ok {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x10
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintWilds(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if len(m.Others) > 0 {
		for _, msg := range m.Others {
			dAtA[i] = 0x22
			i++
			i = encodeVarintWilds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Frame))
	dAtA[i] = 0x40
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.BallId))
	if len(m.Balls) > 0 {
		for _, msg := range m.Balls {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintWilds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Playerballs) > 0 {
		for _, msg := range m.Playerballs {
			dAtA[i] = 0x52
			i++
			i = encodeVarintWilds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x70
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.LeftTime))
	return i, nil
}

func (m *MsgTop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTop) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0xa
			i++
			i = encodeVarintWilds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.EndTime))
	dAtA[i] = 0x20
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Rank))
	dAtA[i] = 0x28
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.KillNum))
	return i, nil
}

func (m *MsgSceneTCP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSceneTCP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Eats) > 0 {
		for _, msg := range m.Eats {
			dAtA[i] = 0xa
			i++
			i = encodeVarintWilds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Adds) > 0 {
		for _, msg := range m.Adds {
			dAtA[i] = 0x12
			i++
			i = encodeVarintWilds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Removes) > 0 {
		for _, num := range m.Removes {
			dAtA[i] = 0x18
			i++
			i = encodeVarintWilds(dAtA, i, uint64(num))
		}
	}
	if len(m.Hits) > 0 {
		for _, msg := range m.Hits {
			dAtA[i] = 0x22
			i++
			i = encodeVarintWilds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AddPlayers) > 0 {
		for _, msg := range m.AddPlayers {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintWilds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RemovePlayers) > 0 {
		for _, num := range m.RemovePlayers {
			dAtA[i] = 0x30
			i++
			i = encodeVarintWilds(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *MsgSceneUDP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSceneUDP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Moves) > 0 {
		for _, msg := range m.Moves {
			dAtA[i] = 0xa
			i++
			i = encodeVarintWilds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Frame))
	return i, nil
}

func (m *MsgPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPlayer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x12
	i++
	i = encodeVarintWilds(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x20
	i++
	if m.IsLive {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.SnapInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWilds(dAtA, i, uint64(m.SnapInfo.Size()))
		n1, err := m.SnapInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	dAtA[i] = 0x30
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.BallId))
	dAtA[i] = 0x38
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Curexp))
	dAtA[i] = 0x40
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Curmp))
	dAtA[i] = 0x50
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Curhp))
	dAtA[i] = 0x60
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.BombNum))
	dAtA[i] = 0x68
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.HammerNum))
	return i, nil
}

func (m *MsgAddPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddPlayer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Player == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("player")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWilds(dAtA, i, uint64(m.Player.Size()))
		n2, err := m.Player.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *MsgRefreshPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRefreshPlayer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Player == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("player")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWilds(dAtA, i, uint64(m.Player.Size()))
		n3, err := m.Player.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *MsgRemovePlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemovePlayer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Id))
	return i, nil
}

func (m *MsgMove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMove) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Angle))
	dAtA[i] = 0x10
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Power))
	dAtA[i] = 0x18
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Face))
	return i, nil
}

func (m *MsgRelife) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRelife) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MsgS2CRelife) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgS2CRelife) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintWilds(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Frame))
	if m.SnapInfo == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("SnapInfo")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWilds(dAtA, i, uint64(m.SnapInfo.Size()))
		n4, err := m.SnapInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Curhp))
	dAtA[i] = 0x28
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Curmp))
	return i, nil
}

func (m *MsgDeath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeath) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.MaxScore))
	dAtA[i] = 0x10
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.KillId))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintWilds(dAtA, i, uint64(len(m.KillName)))
	i += copy(dAtA[i:], m.KillName)
	dAtA[i] = 0x20
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Id))
	return i, nil
}

func (m *MsgEndRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEndRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ClientHeartBeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientHeartBeat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MsgActCloseSocket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActCloseSocket) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MsgCastSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCastSkill) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Skillid))
	return i, nil
}

func (m *MsgRun) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRun) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MsgSceneChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSceneChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintWilds(dAtA, i, uint64(len(m.Msg)))
	i += copy(dAtA[i:], m.Msg)
	dAtA[i] = 0x10
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Id))
	return i, nil
}

func (m *MsgPlayerSnap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPlayerSnap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32Wilds(dAtA, i, uint32(math.Float32bits(float32(m.Snapx))))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32Wilds(dAtA, i, uint32(math.Float32bits(float32(m.Snapy))))
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32Wilds(dAtA, i, uint32(math.Float32bits(float32(m.Angle))))
	dAtA[i] = 0x20
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Id))
	return i, nil
}

func (m *MsgBall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBall) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x18
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.X))
	dAtA[i] = 0x20
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Y))
	return i, nil
}

func (m *MsgPlayerBall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPlayerBall) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x18
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Hp))
	dAtA[i] = 0x20
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Mp))
	dAtA[i] = 0x28
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.X))
	dAtA[i] = 0x30
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Y))
	dAtA[i] = 0x38
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Angle))
	dAtA[i] = 0x40
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Face))
	return i, nil
}

func (m *BallMove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BallMove) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.X))
	dAtA[i] = 0x18
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Y))
	dAtA[i] = 0x20
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.State))
	dAtA[i] = 0x28
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Angle))
	dAtA[i] = 0x30
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Face))
	return i, nil
}

func (m *BallEat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BallEat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Source))
	dAtA[i] = 0x10
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Target))
	return i, nil
}

func (m *HitMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HitMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Source))
	dAtA[i] = 0x10
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.Target))
	dAtA[i] = 0x18
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.AddHp))
	dAtA[i] = 0x20
	i++
	i = encodeVarintWilds(dAtA, i, uint64(m.CurHp))
	return i, nil
}

func encodeFixed64Wilds(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Wilds(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintWilds(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MsgLogin) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovWilds(uint64(l))
	return n
}

func (m *MsgLoginResult) Size() (n int) {
	var l int
	_ = l
	n += 2
	n += 1 + sovWilds(uint64(m.Id))
	l = len(m.Name)
	n += 1 + l + sovWilds(uint64(l))
	if len(m.Others) > 0 {
		for _, e := range m.Others {
			l = e.Size()
			n += 1 + l + sovWilds(uint64(l))
		}
	}
	n += 1 + sovWilds(uint64(m.Frame))
	n += 1 + sovWilds(uint64(m.BallId))
	if len(m.Balls) > 0 {
		for _, e := range m.Balls {
			l = e.Size()
			n += 1 + l + sovWilds(uint64(l))
		}
	}
	if len(m.Playerballs) > 0 {
		for _, e := range m.Playerballs {
			l = e.Size()
			n += 1 + l + sovWilds(uint64(l))
		}
	}
	n += 1 + sovWilds(uint64(m.LeftTime))
	return n
}

func (m *MsgTop) Size() (n int) {
	var l int
	_ = l
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovWilds(uint64(l))
		}
	}
	n += 1 + sovWilds(uint64(m.EndTime))
	n += 1 + sovWilds(uint64(m.Rank))
	n += 1 + sovWilds(uint64(m.KillNum))
	return n
}

func (m *MsgSceneTCP) Size() (n int) {
	var l int
	_ = l
	if len(m.Eats) > 0 {
		for _, e := range m.Eats {
			l = e.Size()
			n += 1 + l + sovWilds(uint64(l))
		}
	}
	if len(m.Adds) > 0 {
		for _, e := range m.Adds {
			l = e.Size()
			n += 1 + l + sovWilds(uint64(l))
		}
	}
	if len(m.Removes) > 0 {
		for _, e := range m.Removes {
			n += 1 + sovWilds(uint64(e))
		}
	}
	if len(m.Hits) > 0 {
		for _, e := range m.Hits {
			l = e.Size()
			n += 1 + l + sovWilds(uint64(l))
		}
	}
	if len(m.AddPlayers) > 0 {
		for _, e := range m.AddPlayers {
			l = e.Size()
			n += 1 + l + sovWilds(uint64(l))
		}
	}
	if len(m.RemovePlayers) > 0 {
		for _, e := range m.RemovePlayers {
			n += 1 + sovWilds(uint64(e))
		}
	}
	return n
}

func (m *MsgSceneUDP) Size() (n int) {
	var l int
	_ = l
	if len(m.Moves) > 0 {
		for _, e := range m.Moves {
			l = e.Size()
			n += 1 + l + sovWilds(uint64(l))
		}
	}
	n += 1 + sovWilds(uint64(m.Frame))
	return n
}

func (m *MsgPlayer) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovWilds(uint64(m.Id))
	l = len(m.Name)
	n += 1 + l + sovWilds(uint64(l))
	n += 2
	if m.SnapInfo != nil {
		l = m.SnapInfo.Size()
		n += 1 + l + sovWilds(uint64(l))
	}
	n += 1 + sovWilds(uint64(m.BallId))
	n += 1 + sovWilds(uint64(m.Curexp))
	n += 1 + sovWilds(uint64(m.Curmp))
	n += 1 + sovWilds(uint64(m.Curhp))
	n += 1 + sovWilds(uint64(m.BombNum))
	n += 1 + sovWilds(uint64(m.HammerNum))
	return n
}

func (m *MsgAddPlayer) Size() (n int) {
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovWilds(uint64(l))
	}
	return n
}

func (m *MsgRefreshPlayer) Size() (n int) {
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovWilds(uint64(l))
	}
	return n
}

func (m *MsgRemovePlayer) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovWilds(uint64(m.Id))
	return n
}

func (m *MsgMove) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovWilds(uint64(m.Angle))
	n += 1 + sovWilds(uint64(m.Power))
	n += 1 + sovWilds(uint64(m.Face))
	return n
}

func (m *MsgRelife) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MsgS2CRelife) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovWilds(uint64(l))
	n += 1 + sovWilds(uint64(m.Frame))
	if m.SnapInfo != nil {
		l = m.SnapInfo.Size()
		n += 1 + l + sovWilds(uint64(l))
	}
	n += 1 + sovWilds(uint64(m.Curhp))
	n += 1 + sovWilds(uint64(m.Curmp))
	return n
}

func (m *MsgDeath) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovWilds(uint64(m.MaxScore))
	n += 1 + sovWilds(uint64(m.KillId))
	l = len(m.KillName)
	n += 1 + l + sovWilds(uint64(l))
	n += 1 + sovWilds(uint64(m.Id))
	return n
}

func (m *MsgEndRoom) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ClientHeartBeat) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MsgActCloseSocket) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MsgCastSkill) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovWilds(uint64(m.Skillid))
	return n
}

func (m *MsgRun) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MsgSceneChat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Msg)
	n += 1 + l + sovWilds(uint64(l))
	n += 1 + sovWilds(uint64(m.Id))
	return n
}

func (m *MsgPlayerSnap) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 5
	n += 5
	n += 1 + sovWilds(uint64(m.Id))
	return n
}

func (m *MsgBall) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovWilds(uint64(m.Id))
	n += 1 + sovWilds(uint64(m.Type))
	n += 1 + sovWilds(uint64(m.X))
	n += 1 + sovWilds(uint64(m.Y))
	return n
}

func (m *MsgPlayerBall) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovWilds(uint64(m.Id))
	n += 1 + sovWilds(uint64(m.Hp))
	n += 1 + sovWilds(uint64(m.Mp))
	n += 1 + sovWilds(uint64(m.X))
	n += 1 + sovWilds(uint64(m.Y))
	n += 1 + sovWilds(uint64(m.Angle))
	n += 1 + sovWilds(uint64(m.Face))
	return n
}

func (m *BallMove) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovWilds(uint64(m.Id))
	n += 1 + sovWilds(uint64(m.X))
	n += 1 + sovWilds(uint64(m.Y))
	n += 1 + sovWilds(uint64(m.State))
	n += 1 + sovWilds(uint64(m.Angle))
	n += 1 + sovWilds(uint64(m.Face))
	return n
}

func (m *BallEat) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovWilds(uint64(m.Source))
	n += 1 + sovWilds(uint64(m.Target))
	return n
}

func (m *HitMsg) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovWilds(uint64(m.Source))
	n += 1 + sovWilds(uint64(m.Target))
	n += 1 + sovWilds(uint64(m.AddHp))
	n += 1 + sovWilds(uint64(m.CurHp))
	return n
}

func sovWilds(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozWilds(x uint64) (n int) {
	return sovWilds(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgLogin) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLogin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLogin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLoginResult) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLoginResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLoginResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Others", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Others = append(m.Others, &MsgPlayer{})
			if err := m.Others[len(m.Others)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frame", wireType)
			}
			m.Frame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frame |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BallId", wireType)
			}
			m.BallId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BallId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balls = append(m.Balls, &MsgBall{})
			if err := m.Balls[len(m.Balls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Playerballs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Playerballs = append(m.Playerballs, &MsgPlayerBall{})
			if err := m.Playerballs[len(m.Playerballs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftTime", wireType)
			}
			m.LeftTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ok")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("frame")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ballId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &MsgPlayer{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillNum", wireType)
			}
			m.KillNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSceneTCP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSceneTCP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSceneTCP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Eats = append(m.Eats, &BallEat{})
			if err := m.Eats[len(m.Eats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Adds = append(m.Adds, &MsgBall{})
			if err := m.Adds[len(m.Adds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWilds
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Removes = append(m.Removes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWilds
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthWilds
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWilds
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Removes = append(m.Removes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Removes", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hits = append(m.Hits, &HitMsg{})
			if err := m.Hits[len(m.Hits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddPlayers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddPlayers = append(m.AddPlayers, &MsgPlayerBall{})
			if err := m.AddPlayers[len(m.AddPlayers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWilds
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RemovePlayers = append(m.RemovePlayers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWilds
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthWilds
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWilds
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RemovePlayers = append(m.RemovePlayers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovePlayers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSceneUDP) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSceneUDP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSceneUDP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Moves = append(m.Moves, &BallMove{})
			if err := m.Moves[len(m.Moves)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frame", wireType)
			}
			m.Frame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frame |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("frame")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPlayer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLive = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnapInfo == nil {
				m.SnapInfo = &MsgPlayerSnap{}
			}
			if err := m.SnapInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BallId", wireType)
			}
			m.BallId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BallId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curexp", wireType)
			}
			m.Curexp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Curexp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curmp", wireType)
			}
			m.Curmp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Curmp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curhp", wireType)
			}
			m.Curhp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Curhp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BombNum", wireType)
			}
			m.BombNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BombNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HammerNum", wireType)
			}
			m.HammerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HammerNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ballId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddPlayer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &MsgPlayer{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("player")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRefreshPlayer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRefreshPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRefreshPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &MsgPlayer{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("player")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemovePlayer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemovePlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemovePlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMove) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			m.Angle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Angle |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			m.Face = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Face |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("angle")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("power")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRelife) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRelife: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRelife: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgS2CRelife) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgS2CRelife: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgS2CRelife: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frame", wireType)
			}
			m.Frame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frame |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnapInfo == nil {
				m.SnapInfo = &MsgPlayerSnap{}
			}
			if err := m.SnapInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curhp", wireType)
			}
			m.Curhp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Curhp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curmp", wireType)
			}
			m.Curmp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Curmp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("SnapInfo")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeath) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxScore", wireType)
			}
			m.MaxScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxScore |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillId", wireType)
			}
			m.KillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KillName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("maxScore")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("killId")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("killName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEndRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEndRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEndRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientHeartBeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientHeartBeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientHeartBeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActCloseSocket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActCloseSocket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActCloseSocket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCastSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCastSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCastSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skillid", wireType)
			}
			m.Skillid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Skillid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRun) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRun: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRun: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSceneChat) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSceneChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSceneChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWilds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Msg")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPlayerSnap) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPlayerSnap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPlayerSnap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapx", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Snapx = float32(math.Float32frombits(v))
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Snapy = float32(math.Float32frombits(v))
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Angle = float32(math.Float32frombits(v))
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Snapx")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Snapy")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Angle")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBall) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("x")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("y")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPlayerBall) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPlayerBall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPlayerBall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			m.Hp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mp", wireType)
			}
			m.Mp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			m.Angle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Angle |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			m.Face = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Face |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("x")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("y")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BallMove) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BallMove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BallMove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			m.Angle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Angle |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			m.Face = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Face |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("x")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("y")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BallEat) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BallEat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BallEat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("source")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("target")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HitMsg) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HitMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HitMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddHp", wireType)
			}
			m.AddHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddHp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurHp", wireType)
			}
			m.CurHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurHp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWilds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWilds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("source")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("target")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWilds(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWilds
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWilds
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthWilds
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowWilds
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipWilds(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthWilds = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWilds   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("wilds.proto", fileDescriptorWilds) }

var fileDescriptorWilds = []byte{
	// 1353 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x4d, 0x6f, 0xdc, 0x54,
	0x17, 0xae, 0x3d, 0x1f, 0xf6, 0x9c, 0xc9, 0x24, 0xce, 0x4d, 0xdf, 0xca, 0x7a, 0xd5, 0x37, 0x1d,
	0xf9, 0xad, 0x68, 0x14, 0x50, 0x16, 0x5d, 0x20, 0x84, 0x10, 0x52, 0x33, 0x1d, 0x94, 0x88, 0x4e,
	0x89, 0x9c, 0x74, 0xc5, 0xca, 0x19, 0xdf, 0xf1, 0x98, 0xb1, 0x7d, 0x2d, 0x5f, 0x4f, 0x9b, 0x91,
	0xd8, 0xc0, 0xa6, 0x2c, 0xbb, 0xee, 0x9f, 0x80, 0x9f, 0xc0, 0x06, 0xa9, 0x62, 0xc5, 0x2f, 0x40,
	0xa8, 0xac, 0xf8, 0x10, 0x08, 0x10, 0x88, 0x05, 0x48, 0xe8, 0x1c, 0x7f, 0x8c, 0x9d, 0x49, 0x8a,
	0x04, 0xab, 0x99, 0xfb, 0x9c, 0xcf, 0x7b, 0xce, 0x73, 0xce, 0x35, 0x74, 0x1f, 0xf9, 0x81, 0x2b,
	0xf7, 0xe2, 0x44, 0xa4, 0x82, 0x69, 0x73, 0xc9, 0x93, 0x71, 0xe8, 0x5a, 0x37, 0x41, 0x1f, 0x49,
	0xef, 0x9e, 0xf0, 0xfc, 0x88, 0x99, 0xd0, 0x8c, 0x9c, 0x90, 0x9b, 0x4a, 0x5f, 0xdd, 0xe9, 0xec,
	0x37, 0x9f, 0x7d, 0x79, 0xe3, 0x8a, 0x4d, 0x88, 0xf5, 0xa9, 0x0a, 0xeb, 0x85, 0x9a, 0xcd, 0xe5,
	0x3c, 0x48, 0xd9, 0x55, 0x50, 0xc5, 0x8c, 0x54, 0xf5, 0x5c, 0x55, 0x15, 0x33, 0x44, 0x7d, 0xd7,
	0x54, 0xfb, 0xea, 0x4e, 0xb3, 0x40, 0x7d, 0xb7, 0x74, 0xdc, 0xe8, 0x2b, 0x75, 0xc7, 0x6c, 0x17,
	0xda, 0x22, 0x9d, 0xf2, 0x44, 0x9a, 0xcd, 0x7e, 0x63, 0xa7, 0x7b, 0x9b, 0xed, 0xe5, 0x89, 0xed,
	0x8d, 0xa4, 0x77, 0x14, 0x38, 0x0b, 0x9e, 0xd8, 0xb9, 0x06, 0xfb, 0x2f, 0xb4, 0x26, 0x09, 0xba,
	0x69, 0xf5, 0xd5, 0x9d, 0x5e, 0xee, 0x26, 0x83, 0xd8, 0x75, 0x68, 0x9f, 0x3a, 0x41, 0x70, 0xe8,
	0x9a, 0x7a, 0x45, 0x98, 0x63, 0xec, 0x25, 0x68, 0xe1, 0x3f, 0x69, 0x76, 0x28, 0x88, 0x51, 0x0d,
	0xb2, 0xef, 0x04, 0x81, 0x9d, 0x89, 0xd9, 0x6b, 0xd0, 0x8d, 0x29, 0x66, 0xa6, 0x0d, 0xa4, 0x7d,
	0x6d, 0x35, 0x25, 0xb2, 0xa9, 0xaa, 0xb2, 0x3e, 0xe8, 0x01, 0x9f, 0xa4, 0x27, 0x7e, 0xc8, 0xcd,
	0xf5, 0xbe, 0x52, 0x66, 0x50, 0xa2, 0xd6, 0x13, 0x05, 0xda, 0x23, 0xe9, 0x9d, 0x88, 0x98, 0xbd,
	0x02, 0x5a, 0x66, 0x2b, 0x4d, 0xe5, 0xd2, 0x5b, 0x17, 0x2a, 0x6c, 0x1b, 0xb4, 0x61, 0xe4, 0x92,
	0xe7, 0x46, 0xc5, 0xb3, 0xc6, 0x33, 0x10, 0x8b, 0x6b, 0x3b, 0xd1, 0xcc, 0x6c, 0x56, 0x84, 0xcd,
	0xc4, 0x89, 0x66, 0x68, 0xf9, 0xb6, 0x1f, 0x04, 0xf7, 0xe7, 0xa1, 0xd9, 0xaa, 0x5a, 0xce, 0x32,
	0xd0, 0xfa, 0x4d, 0x81, 0xee, 0x48, 0x7a, 0xc7, 0x63, 0x1e, 0xf1, 0x93, 0xc1, 0x11, 0xbb, 0x09,
	0x4d, 0xee, 0xa4, 0x45, 0x52, 0xcb, 0x2a, 0xe1, 0x75, 0x87, 0x4e, 0x6a, 0x93, 0x14, 0xb5, 0x1c,
	0xd7, 0x95, 0xa6, 0x7a, 0x49, 0x2d, 0x49, 0xca, 0x4c, 0xd0, 0x12, 0x1e, 0x8a, 0x87, 0x5c, 0x9a,
	0x8d, 0x7e, 0x63, 0xa7, 0x67, 0x17, 0x47, 0xf6, 0x7f, 0x68, 0x4e, 0xfd, 0xb4, 0x68, 0xf8, 0x46,
	0x69, 0x7f, 0xe0, 0xa7, 0x23, 0xe9, 0xd9, 0x24, 0x64, 0xaf, 0x02, 0x38, 0xae, 0x7b, 0x94, 0x57,
	0xa9, 0xf5, 0xc2, 0x46, 0x54, 0x34, 0xd9, 0x4d, 0xe8, 0x65, 0x71, 0x0a, 0xd3, 0x36, 0x05, 0xaf,
	0x83, 0x96, 0xbd, 0xbc, 0xf7, 0x83, 0xbb, 0x47, 0xec, 0x16, 0xb4, 0xb2, 0x4c, 0xb3, 0x8b, 0x6f,
	0xd6, 0x2e, 0x3e, 0x12, 0x0f, 0xb9, 0x9d, 0xc9, 0x97, 0x0c, 0x54, 0x57, 0x18, 0x68, 0x7d, 0xa6,
	0x42, 0xa7, 0xcc, 0x2b, 0x9f, 0x03, 0xe5, 0x92, 0x39, 0x50, 0xcf, 0x0f, 0x18, 0xf2, 0xf7, 0x50,
	0xde, 0xf3, 0x1f, 0x72, 0x6a, 0x63, 0x31, 0x51, 0x6d, 0x9f, 0x30, 0x76, 0x1b, 0xf4, 0xe3, 0xc8,
	0x89, 0x0f, 0xa3, 0x89, 0xa0, 0x4e, 0x5e, 0x58, 0x0b, 0xd4, 0xb0, 0x75, 0x99, 0xeb, 0x55, 0x26,
	0xa2, 0x7d, 0xc1, 0x44, 0x5c, 0x87, 0xf6, 0x78, 0x9e, 0xf0, 0xb3, 0xd8, 0xd4, 0x2a, 0xcc, 0xc8,
	0x31, 0xbc, 0xe7, 0x78, 0x9e, 0x84, 0xb1, 0xa9, 0x57, 0x84, 0x19, 0x94, 0xcb, 0xa6, 0xb1, 0x09,
	0xe7, 0x64, 0xd3, 0x18, 0x09, 0x77, 0x2a, 0xc2, 0x53, 0x24, 0xdc, 0x5a, 0x5f, 0xd9, 0x69, 0x15,
	0x84, 0xcb, 0x41, 0x66, 0x41, 0x67, 0xea, 0x84, 0x21, 0x4f, 0x50, 0xa3, 0x57, 0xd1, 0x58, 0xc2,
	0xd6, 0xeb, 0xb0, 0x36, 0x92, 0xde, 0x9d, 0xa2, 0xa5, 0xb8, 0x21, 0xb2, 0x49, 0xa0, 0x6a, 0x5e,
	0xb2, 0x21, 0x32, 0x0d, 0xeb, 0x4d, 0x30, 0x90, 0x42, 0x7c, 0x92, 0x70, 0x39, 0xfd, 0x07, 0xf6,
	0xb7, 0x60, 0x83, 0xec, 0x97, 0x5c, 0xb9, 0xb8, 0x91, 0xd6, 0xbb, 0xa0, 0x8d, 0xa4, 0x87, 0xd4,
	0xc0, 0x7a, 0x38, 0x91, 0x17, 0x64, 0x5b, 0xb3, 0xb8, 0x4f, 0x06, 0xa1, 0x2c, 0x16, 0x8f, 0x78,
	0x42, 0x0d, 0x2f, 0x65, 0x04, 0x21, 0x17, 0x26, 0xce, 0xb8, 0x3e, 0xd3, 0x84, 0x58, 0x5d, 0x22,
	0x92, 0xcd, 0x03, 0x7f, 0xc2, 0xad, 0x4f, 0x14, 0xaa, 0xc7, 0xf1, 0xed, 0x41, 0x06, 0x54, 0x96,
	0xf4, 0xf9, 0x5d, 0x5a, 0x61, 0xa7, 0x72, 0x7e, 0x3f, 0x56, 0x19, 0xd4, 0xa0, 0x3a, 0xfc, 0x3d,
	0x83, 0xca, 0x4e, 0x37, 0x57, 0x3b, 0x5d, 0x32, 0xa4, 0xb5, 0xc2, 0x10, 0xeb, 0x43, 0x85, 0xde,
	0x94, 0xbb, 0xdc, 0x49, 0xa7, 0xb8, 0x18, 0x43, 0xe7, 0xec, 0x78, 0x2c, 0x92, 0xac, 0x42, 0xe5,
	0x62, 0x2c, 0x50, 0xa4, 0x22, 0x2e, 0xa4, 0xc3, 0xfa, 0xb3, 0x91, 0x63, 0x68, 0x4f, 0xeb, 0x2a,
	0x7b, 0x3e, 0x96, 0x63, 0x53, 0xa2, 0xd8, 0xa1, 0x43, 0xd7, 0x6c, 0x9e, 0xeb, 0xd0, 0x1a, 0xc0,
	0x48, 0x7a, 0xc3, 0xc8, 0xb5, 0x85, 0x08, 0xad, 0x4d, 0xd8, 0x18, 0x04, 0x3e, 0x8f, 0xd2, 0x03,
	0xee, 0x24, 0xe9, 0x3e, 0x77, 0x52, 0x6b, 0x0b, 0x36, 0x91, 0x67, 0xe3, 0x74, 0x10, 0x08, 0xc9,
	0x8f, 0xc5, 0x78, 0xc6, 0x53, 0x6b, 0x8f, 0x8a, 0x3d, 0x70, 0x64, 0x7a, 0x8c, 0xfe, 0x91, 0xd0,
	0x12, 0xff, 0x10, 0x05, 0x2a, 0x1b, 0x34, 0x07, 0x2d, 0x9d, 0x76, 0xba, 0x3d, 0x8f, 0xac, 0x37,
	0xb2, 0x36, 0xe1, 0x4a, 0x19, 0x4c, 0x9d, 0x94, 0x5d, 0x83, 0xc6, 0x48, 0x7a, 0xb5, 0xa7, 0xb4,
	0x11, 0x4a, 0x2f, 0xcf, 0xf6, 0xdc, 0x03, 0x69, 0x2d, 0xa0, 0x57, 0xeb, 0x02, 0xd6, 0x17, 0x7f,
	0xcf, 0xc8, 0x81, 0x5a, 0xd4, 0x17, 0x5b, 0x73, 0x56, 0xc8, 0x16, 0xe4, 0xa5, 0x26, 0x5b, 0xa0,
	0xec, 0x0e, 0xb1, 0xb1, 0x51, 0x95, 0x65, 0x6c, 0xbc, 0xb8, 0x50, 0x0e, 0x51, 0x19, 0x37, 0x5d,
	0x85, 0xeb, 0xbd, 0xfa, 0xd2, 0x4a, 0x17, 0x31, 0xaf, 0x71, 0x98, 0x10, 0xc6, 0x40, 0x39, 0xa3,
	0x40, 0x05, 0xac, 0x9c, 0x21, 0xb6, 0xa0, 0x18, 0x25, 0xb6, 0xb0, 0x3e, 0x56, 0x2a, 0xd7, 0x7b,
	0x41, 0xa4, 0xab, 0xa0, 0x4e, 0xe3, 0xda, 0x40, 0xa8, 0xd3, 0x18, 0xd1, 0xb0, 0xce, 0x41, 0x35,
	0x8c, 0xb3, 0xd8, 0xad, 0x0b, 0x62, 0xb7, 0x6b, 0xb1, 0x97, 0xe3, 0xa9, 0x55, 0xd6, 0x4d, 0x5e,
	0x90, 0x62, 0x04, 0xf5, 0x95, 0x11, 0x7c, 0xaa, 0x80, 0x5e, 0x2c, 0xff, 0x4b, 0x92, 0xa5, 0x04,
	0xd4, 0x0b, 0x12, 0x68, 0xac, 0x24, 0x20, 0x53, 0x27, 0xe5, 0xf5, 0x29, 0x22, 0x68, 0x99, 0x5c,
	0xeb, 0xf2, 0xe4, 0xda, 0x2b, 0xc9, 0x0d, 0x41, 0xcb, 0x5f, 0x64, 0x9c, 0x1d, 0x29, 0xe6, 0xc9,
	0xb8, 0x3e, 0x5b, 0x39, 0x86, 0xd2, 0xd4, 0x49, 0x3c, 0x9e, 0xd6, 0xde, 0xab, 0x1c, 0xb3, 0xde,
	0x87, 0x76, 0xf6, 0xe4, 0xfe, 0x1b, 0x2f, 0x74, 0x05, 0xd7, 0x3d, 0xc8, 0xda, 0xb6, 0xbc, 0x02,
	0x42, 0xf9, 0x92, 0x38, 0x58, 0x5d, 0x20, 0x07, 0xf1, 0xee, 0x63, 0x95, 0x06, 0xf4, 0x64, 0x11,
	0xf3, 0x41, 0xe8, 0x32, 0x80, 0x16, 0x7d, 0x5c, 0x1a, 0xdf, 0x68, 0x4c, 0x87, 0xc6, 0x89, 0x88,
	0x8d, 0x6f, 0x35, 0xb6, 0x0e, 0x9d, 0xf2, 0x21, 0x30, 0xbe, 0xd3, 0xd8, 0x26, 0xac, 0x55, 0x97,
	0xb3, 0xf1, 0xbd, 0xc6, 0x3a, 0xd0, 0xc4, 0x26, 0x19, 0x3f, 0x90, 0x9d, 0x3d, 0x8f, 0x8c, 0x1f,
	0x35, 0xd6, 0x85, 0xb6, 0xcd, 0xef, 0xf9, 0x13, 0x6e, 0xfc, 0xa4, 0xa1, 0x6b, 0x5a, 0x45, 0xc6,
	0xcf, 0x1a, 0x5b, 0xa3, 0x6f, 0x29, 0x5c, 0x09, 0xc6, 0x2f, 0x1a, 0x63, 0xd0, 0xab, 0xbd, 0x15,
	0xc6, 0xaf, 0x14, 0xb2, 0xdc, 0x11, 0xc6, 0xef, 0x74, 0x2e, 0x87, 0xda, 0xf8, 0x43, 0x63, 0x5b,
	0xb0, 0x5e, 0xdf, 0x19, 0xc6, 0x9f, 0x1a, 0xeb, 0x81, 0x3e, 0x4c, 0x12, 0x91, 0x8c, 0xa4, 0x67,
	0x7c, 0xa0, 0xe3, 0xb1, 0xf8, 0xa6, 0x32, 0x1e, 0x2f, 0x8f, 0x0f, 0xee, 0x1e, 0x19, 0x1f, 0xe9,
	0xe8, 0xb1, 0x5c, 0x30, 0xc6, 0x53, 0x7d, 0xf7, 0x65, 0xd8, 0x1a, 0x39, 0xf1, 0x3b, 0xa7, 0xef,
	0xf1, 0x71, 0x3a, 0x10, 0xd1, 0xc4, 0xa7, 0xa2, 0xb0, 0x0e, 0xb4, 0x86, 0x61, 0x9c, 0x2e, 0x8c,
	0x2b, 0xf8, 0x77, 0x3f, 0x10, 0xe3, 0x99, 0xa1, 0xec, 0x7e, 0x9e, 0x13, 0x93, 0x54, 0x00, 0xda,
	0x79, 0xe2, 0x0a, 0xeb, 0x41, 0xe7, 0x2d, 0x21, 0xdc, 0x7d, 0x8e, 0x45, 0x04, 0xb6, 0x0e, 0x80,
	0xc7, 0xfb, 0x22, 0x09, 0x9d, 0xc0, 0xe8, 0x16, 0xe7, 0x03, 0x7a, 0x66, 0x8d, 0x35, 0xb6, 0x06,
	0x3a, 0xa9, 0x8b, 0xf0, 0xd4, 0xe8, 0xb1, 0x2e, 0x68, 0x78, 0x1a, 0x46, 0xae, 0xb1, 0x45, 0x9e,
	0x38, 0xcf, 0x3d, 0x5d, 0x25, 0x4b, 0xce, 0x0b, 0x4f, 0xff, 0x21, 0x5d, 0xce, 0x49, 0xf7, 0x7f,
	0x28, 0xa4, 0x7b, 0x64, 0xca, 0xdb, 0x6c, 0x03, 0xba, 0x74, 0xce, 0xe3, 0xdc, 0x40, 0x67, 0x99,
	0x02, 0x06, 0xea, 0x63, 0x58, 0x3a, 0xa2, 0xf5, 0xad, 0x7d, 0xe3, 0xd9, 0xf3, 0x6d, 0xe5, 0x8b,
	0xe7, 0xdb, 0xca, 0x57, 0xcf, 0xb7, 0x95, 0x27, 0x5f, 0x6f, 0x5f, 0xf9, 0x2b, 0x00, 0x00, 0xff,
	0xff, 0x4f, 0x10, 0x1a, 0x7a, 0xa4, 0x0c, 0x00, 0x00,
}
